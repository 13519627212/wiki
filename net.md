# Network Design Document

## Network Protocol

We build our peer-to-peer network connection based on [libp2p](https://libp2p.io). [Libp2p](https://libp2p.io) is the foundamental network library of [IPFS](https://ipfs.io), with high performance and stability.

In Nebulas, we define our own wire protocol, as the following:
```
 0               1               2               3              (bytes)
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Number                          |
+-----------------------------------------------+-------+-------+
|                         Chain ID              |Length |Version|
+-----------------------------------------------+-------+-------+
|                         Message Name                          |
+---------------------------------------------------------------+
|                         Data Length                           |
+---------------------------------------------------------------+
|                         Data Checksum                         |
+---------------------------------------------------------------+
|                         Header Checksum                       |
|---------------------------------------------------------------+
|                                                               |
+                             Data                              +
|                                                               |
+---------------------------------------------------------------+
```

* Magic Number: 32 bits (4 chars)
  * The protocol magic number, A constant numerical or text value used to identify protocol.
  * Default: "NEB1"

* Chain ID: 24 bits
  * The Chain ID is used to distinguish the test network and the main network.

* Length: 4 bits
  * The length of the Message Name.

* Version: 4 bits
  * The version of the Message Name.

* Message Name: variable length, max 16 chars
  * The identification or the name of the Message.

* Data Length: 32 bits
  * The total length of the Data.

* Data Checksum: 32 bits
  * The CRC32 checksum of the Data.

* Header Checksum: 32 bits
  * The CRC32 checksum of the fields from Magic Number to Data Checksum.

* Data: variable length, max 4G.
  * The message data.

We always use Big-Endian in message protocol.

## Handshaking Messages

* Hello

the handshaking message when peer connect to others.

```
version: 0x1

data: struct {
    string node_id  // the node id, generated by underlying libp2p.
    string client_version // the client version, x.y.z schema, eg. 0.1.0.
}
```

* OK

the response message for handshaking.

```
version: 0x1

data: struct {
    string node_id // the node id, generated by underlying libp2p.
    string node_version // the client version, x.y.z schema, eg. 0.1.0.
}
```

* Bye

the message to close connection.

```
version: 0x1
data: struct {
    string reason
}
```

## Networking Messages

* NetSyncRoutes

request peers to sync route tables.

```
version: 0x1
```

* NetRoutes

contains the local route tables.

```
version: 0x1
data: struct {
    PeerID[] peer_ids // router tables.
}

struct PeerID {
    string node_id  // the node id.
}
```


## Nebulas Messages

TBD.

## Network architecture
Our network simply provides the simplest peer-to-peer data propagation without the business. we threw our specific business to the top dispatcher. we use p2p_manager to manage our p2p message and message broadcast.
